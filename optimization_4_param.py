import numpy as np

from functions import find_k

# Универсальная газовая постоянная
R = 1.987


# Метод Рунге-Кутты четвертого порядка для вычисления текущей концентрации глюкозы

def find_g(k0_1, en1, k0_2, en2, g0, temp, time, h=1):
    """
    Расчет концентрации глюкозы в момент времени t
    :param k0_1: пред экспоненциальный фактор для глюкозы
    :param en1: энергия активации для глюкозы
    :param k0_2: пред экспоненциальный фактор для фруктозы
    :param en2: энергия активации для фруктозы
    :param g0: начальная концентрация глюкозы при t = 0
    :param temp: температура при которой происходит реакция
    :param time: момент времени t
    :param h: шаг метода Рунге-Кутты
    :returns: концентрацию глюкозы в момент времени t
    """
    # Функция расчета производной концентрации глюкозы по времени
    def f(g):
        k2 = find_k(k0_2, en2, temp)
        k1 = find_k(k0_1, en1, temp)
        return k2 * (g0 - g) - k1 * g
    # Нулевой момент времени
    t_i = 0
    # Значение концентрации глюкозы в момент времени t_1
    G_i = g0
    # Цикл вычисления концентрации глюкозы в момент времени t
    while t_i < time:
        t_i += h
        # промежуточный расчет
        K1 = f(G_i)
        K2 = f(G_i + h/2*K1)
        K3 = f(G_i + h/2*K2)
        K4 = f(G_i + h*K3)
        # значение концентрации для t_i + h
        G_i += h/6*(K1+2*K2+2*K3+K4)
    return G_i

def loss_function(k0_1, en1, k0_2, en2, x, y):
    """
    Функция потерь для модели
    :param k0_1: пред экспоненциальный фактор для глюкозы
    :param en1: энергия активации для глюкозы
    :param k0_2: пред экспоненциальный фактор для фруктозы
    :param en2: энергия активации для фруктозы
    :param x: матрица входных данных, каждая строчка содержит начальную концентрацию глюкозы, температуру и время
    :param y: вектор экспериментальных данных, концентраций глюкозы
    :return: Сумма квадратов разностей расчетной концентрации глюкозы и экспериментальной
    """
    # Инициализация потерь
    loss = 0
    # Расчет потерь
    if isinstance(y, (float, int)): return (y - find_g(k0_1, en1, k0_2, en2, *x)) ** 2
    for i in range(len(x)):
        loss += (y[i] - find_g(k0_1, en1, k0_2, en2, *x[i])) ** 2
    # Очень важно, чтобы величина функции потерь не зависела от количества входных данных. Для этого, например, можно вычислять среднее суммы
    # Иначе параметр alpha (скорость спуска) будет необходимо подбирать, например, отдельно, для каждого размера пакета
    return loss/len(x)

def generate_data(seed):
    """
    Функция генерации данных
    :param seed: Значение инициализации рандома
    :return: матрица входных данных x [g0, temp, time] и вектор экспериментальных данных y [g]
    """
    # параметры, найденные в статье
    k0_1 = 5.91e5
    en1 = 10733
    k0_2 = 2.07
    en2 = 2224
    # инициализация гсч
    np.random.seed(seed)
    x = []
    y = []
    # цикл генерации данных
    for g0 in [10, 15, 20]:
        for T in [323.15, 333.15, 343.15]:
            time = 0
            while time <= 40:
                x.append([g0, T, time])
                g = find_g(k0_1, en1, k0_2, en2, g0, T, time)
                # имитируем погрешность измерений в 5 процентов максимум
                g += g * np.random.uniform(-0.05, 0.05)
                y.append(g)
                # увеличиваем время на случайное число от 1 до 5
                time += np.random.randint(1, 6)
    return x, y