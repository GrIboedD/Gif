import numpy as np


# Метод Рунге-Кутты четвертого порядка для вычисления текущей концентрации глюкозы

def find_g(k1, k2, g0, time, h=0.5):
    """
    Расчет концентрации глюкозы в момент времени t
    :param k1: константа скорости реакции глюкозы
    :param k2: константа скорости реакции фруктозы
    :param g0: начальная концентрация глюкозы при t = 0
    :param time: момент времени t
    :param h: шаг метода Рунге-Кутты
    :returns: концентрацию глюкозы в момент времени t
    """
    # Функция расчета производной концентрации глюкозы по времени
    def f(g): return k2 * (g0 - g) - k1 * g
    # Нулевой момент времени
    t_i = 0
    # Значение концентрации глюкозы в момент времени t_1
    G_i = g0
    # Цикл вычисления концентрации глюкозы в момент времени t
    while t_i < time:
        t_i += h
        # промежуточный расчет
        K1 = f(G_i)
        K2 = f(G_i + h/2*K1)
        K3 = f(G_i + h/2*K2)
        K4 = f(G_i + h*K3)
        # значение концентрации для t_i + h
        G_i += h/6*(K1+2*K2+2*K3+K4)
    return G_i

def loss_function(k1, k2, x, y):
    """
    Функция потерь для модели
    :param k1: константа скорости реакции глюкозы
    :param k2: константа скорости реакции фруктозы
    :param x: матрица входных данных, каждая строчка содержит начальную концентрацию глюкозы, температуру и время
    :param y: вектор экспериментальных данных, концентраций глюкозы
    :return: Сумма квадратов разностей расчетной концентрации глюкозы и экспериментальной
    """
    # Инициализация потерь
    loss = 0
    # Расчет потерь
    if isinstance(y, (float, int)): return (y - find_g(k1, k2, *x)) ** 2
    for i in range(len(x)):
        loss += (y[i] - find_g(k1, k2, *x[i])) ** 2
    # Очень важно, чтобы величина функции потерь не зависела от количества входных данных. Для этого, например, можно вычислять среднее суммы
    # Иначе параметр alpha (скорость спуска) будет необходимо подбирать, например, отдельно, для каждого размера пакета
    return loss/len(x)

def generate_data(seed):
    """
    Функция генерации данных
    :param seed: Значение инициализации рандома
    :return: матрица входных данных x [g0, temp, time] и вектор экспериментальных данных y [g]
    """
    # параметры, найденные в статье
    k1 = 0.0310
    k2 = 0.0653
    # инициализация гсч
    np.random.seed(seed)
    x = []
    y = []
    # цикл генерации данных
    for g0 in [10, 15, 20]:
        time = 0
        while time <= 40:
            x.append([g0, time])
            g = find_g(k1, k2, g0, time)
            # имитируем погрешность измерений в 5 процентов максимум
            g += g * np.random.uniform(-0.05, 0.05)
            y.append(g)
            # увеличиваем время на случайное число от 1 до 5
            time += np.random.randint(1, 6)
    return x, y